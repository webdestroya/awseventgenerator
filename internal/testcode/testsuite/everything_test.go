// Code generated by awseventgenerator/internal/generators/testcode. DO NOT EDIT.

package testsuitegenerated

import (
	"encoding/json"
	"github.com/stretchr/testify/require"
	"testing"
	"time"

	everything "github.com/webdestroya/awseventgenerator/internal/testcode/everything_gen"
)

func TestGenerated_everything(t *testing.T) {

	strVal := "someString"
	floatVal := float64(1232.1424)
	intVal := int64(1232)
	timeVal := time.Now().UTC()
	trueVal := true
	anyVal := struct {
		Thing string `json:"thinger"`
	}{Thing: "anywayanyday"}

	require.IsType(t, *new(string), strVal)
	require.IsType(t, *new(float64), floatVal)
	require.IsType(t, *new(int64), intVal)
	require.IsType(t, *new(time.Time), timeVal)
	require.IsType(t, *new(bool), trueVal)
	_ = anyVal

	t.Run("constants", func(t *testing.T) {
		require.Equal(t, `EverythingTest`, everything.AwsEventDetailType)
		require.Equal(t, `webdestroya.everything`, everything.AwsEventSource)
	})

	t.Run("enums", func(t *testing.T) {
		t.Run("ReadinessStatusType", func(t *testing.T) {
			require.Equal(t, "NOT_AUTHORIZED", string(everything.ReadinessStatusTypeNotAuthorized))
			require.Contains(t, everything.ReadinessStatusTypeNotAuthorized.Values(), everything.ReadinessStatusTypeNotAuthorized)

			require.Equal(t, "NOT_READY", string(everything.ReadinessStatusTypeNotReady))
			require.Contains(t, everything.ReadinessStatusTypeNotReady.Values(), everything.ReadinessStatusTypeNotReady)

			require.Equal(t, "READY", string(everything.ReadinessStatusTypeReady))
			require.Contains(t, everything.ReadinessStatusTypeReady.Values(), everything.ReadinessStatusTypeReady)

			require.Equal(t, "UNKNOWN", string(everything.ReadinessStatusTypeUnknown))
			require.Contains(t, everything.ReadinessStatusTypeUnknown.Values(), everything.ReadinessStatusTypeUnknown)

		})
	})

	t.Run("aliases", func(t *testing.T) {
		require.IsType(t, *new(map[string]string), *new(everything.Environment))
	})

	t.Run("structs", func(t *testing.T) {
		t.Run("AttachmentDetails", func(t *testing.T) {
			genStruct := &everything.AttachmentDetails{
				Details: &everything.Details{
					Name:  &strVal,
					Value: &strVal,
				},
				Id:     &strVal,
				Status: &strVal,
				Type:   &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.AttachmentDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("details")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"id"`, strVal, "Id")
				requireJmesMatch(t, jsearch, `"status"`, strVal, "Status")
				requireJmesMatch(t, jsearch, `"type"`, strVal, "Type")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.Details) // Lazily Tested: everything.AttachmentDetails.Details == *Details
				require.Equal(t, strVal, *everything.AttachmentDetails{Id: &strVal}.Id)
				require.Equal(t, strVal, *everything.AttachmentDetails{Status: &strVal}.Status)
				require.Equal(t, strVal, *everything.AttachmentDetails{Type: &strVal}.Type)
			})
		})

		t.Run("AttributesDetails", func(t *testing.T) {
			genStruct := &everything.AttributesDetails{
				Name:  &strVal,
				Value: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.AttributesDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				requireJmesMatch(t, jsearch, `"value"`, strVal, "Value")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *everything.AttributesDetails{Name: &strVal}.Name)
				require.Equal(t, strVal, *everything.AttributesDetails{Value: &strVal}.Value)
			})
		})

		t.Run("ContainerDetails", func(t *testing.T) {
			genStruct := &everything.ContainerDetails{
				ContainerArn:      strVal,
				Cpu:               &strVal,
				ExitCode:          &floatVal,
				GpuIds:            []string{strVal},
				Image:             &strVal,
				ImageDigest:       &strVal,
				LastStatus:        strVal,
				Memory:            &strVal,
				MemoryReservation: &strVal,
				Name:              strVal,
				NetworkBindings: []everything.NetworkBindingDetails{{
					BindIP:        &strVal,
					ContainerPort: &floatVal,
					HostPort:      &floatVal,
					Protocol:      &strVal,
				}},
				NetworkInterfaces: []everything.NetworkInterfaceDetails{{
					AttachmentId:       &strVal,
					Ipv6Address:        &strVal,
					PrivateIpv4Address: &strVal,
				}},
				Reason:    &strVal,
				RuntimeId: &strVal,
				TaskArn:   strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.ContainerDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"containerArn"`, strVal, "ContainerArn")
				requireJmesMatch(t, jsearch, `"cpu"`, strVal, "Cpu")
				requireJmesMatch(t, jsearch, `"exitCode"`, floatVal, "ExitCode")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("gpuIds")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"image"`, strVal, "Image")
				requireJmesMatch(t, jsearch, `"imageDigest"`, strVal, "ImageDigest")
				requireJmesMatch(t, jsearch, `"lastStatus"`, strVal, "LastStatus")
				requireJmesMatch(t, jsearch, `"memory"`, strVal, "Memory")
				requireJmesMatch(t, jsearch, `"memoryReservation"`, strVal, "MemoryReservation")
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("networkBindings")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("networkInterfaces")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"reason"`, strVal, "Reason")
				requireJmesMatch(t, jsearch, `"runtimeId"`, strVal, "RuntimeId")
				requireJmesMatch(t, jsearch, `"taskArn"`, strVal, "TaskArn")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, everything.ContainerDetails{ContainerArn: strVal}.ContainerArn)
				require.Equal(t, strVal, *everything.ContainerDetails{Cpu: &strVal}.Cpu)
				require.Equal(t, floatVal, *everything.ContainerDetails{ExitCode: &floatVal}.ExitCode)
				require.Contains(t, everything.ContainerDetails{GpuIds: []string{strVal}}.GpuIds, strVal)
				require.Equal(t, strVal, *everything.ContainerDetails{Image: &strVal}.Image)
				require.Equal(t, strVal, *everything.ContainerDetails{ImageDigest: &strVal}.ImageDigest)
				require.Equal(t, strVal, everything.ContainerDetails{LastStatus: strVal}.LastStatus)
				require.Equal(t, strVal, *everything.ContainerDetails{Memory: &strVal}.Memory)
				require.Equal(t, strVal, *everything.ContainerDetails{MemoryReservation: &strVal}.MemoryReservation)
				require.Equal(t, strVal, everything.ContainerDetails{Name: strVal}.Name)
				require.NotNil(t, genStruct.NetworkBindings)   // Lazily Tested: everything.ContainerDetails.NetworkBindings == []NetworkBindingDetails
				require.NotNil(t, genStruct.NetworkInterfaces) // Lazily Tested: everything.ContainerDetails.NetworkInterfaces == []NetworkInterfaceDetails
				require.Equal(t, strVal, *everything.ContainerDetails{Reason: &strVal}.Reason)
				require.Equal(t, strVal, *everything.ContainerDetails{RuntimeId: &strVal}.RuntimeId)
				require.Equal(t, strVal, everything.ContainerDetails{TaskArn: strVal}.TaskArn)
			})
		})

		t.Run("Details", func(t *testing.T) {
			genStruct := &everything.Details{
				Name:  &strVal,
				Value: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.Details{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				requireJmesMatch(t, jsearch, `"value"`, strVal, "Value")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *everything.Details{Name: &strVal}.Name)
				require.Equal(t, strVal, *everything.Details{Value: &strVal}.Value)
			})
		})

		t.Run("ECSTaskStateChange", func(t *testing.T) {
			genStruct := &everything.ECSTaskStateChange{
				Attachments: []everything.AttachmentDetails{{
					Details: &everything.Details{
						Name:  &strVal,
						Value: &strVal,
					},
					Id:     &strVal,
					Status: &strVal,
					Type:   &strVal,
				}},
				Attributes: []everything.AttributesDetails{{
					Name:  &strVal,
					Value: &strVal,
				}},
				AvailabilityZone:     &strVal,
				ClusterArn:           strVal,
				Connectivity:         &strVal,
				ConnectivityAt:       &timeVal,
				ContainerInstanceArn: &strVal,
				Containers: []everything.ContainerDetails{{
					ContainerArn:      strVal,
					Cpu:               &strVal,
					ExitCode:          &floatVal,
					GpuIds:            []string{strVal},
					Image:             &strVal,
					ImageDigest:       &strVal,
					LastStatus:        strVal,
					Memory:            &strVal,
					MemoryReservation: &strVal,
					Name:              strVal,
					NetworkBindings: []everything.NetworkBindingDetails{{
						BindIP:        &strVal,
						ContainerPort: &floatVal,
						HostPort:      &floatVal,
						Protocol:      &strVal,
					}},
					NetworkInterfaces: []everything.NetworkInterfaceDetails{{
						AttachmentId:       &strVal,
						Ipv6Address:        &strVal,
						PrivateIpv4Address: &strVal,
					}},
					Reason:    &strVal,
					RuntimeId: &strVal,
					TaskArn:   strVal,
				}},
				Cpu:                &strVal,
				CreatedAt:          timeVal,
				DesiredStatus:      strVal,
				ExecutionStoppedAt: &timeVal,
				Extraobj: &everything.ExtraWithStrings{
					AdditionalProperties: map[string]string{
						strVal: strVal,
					},
					Somenum:  &floatVal,
					Someprop: &strVal,
				},
				Group:      &strVal,
				LastStatus: strVal,
				LaunchType: &strVal,
				Memory:     &strVal,
				Overrides: &everything.Overrides{
					ContainerOverrides: []everything.OverridesItem{{
						Command: []string{strVal},
						Cpu:     &floatVal,
						Environment: []everything.Environment{map[string]string{
							strVal: strVal,
						}},
						Memory: &floatVal,
						Name:   strVal,
					}},
				},
				PlatformVersion:   &strVal,
				PullStartedAt:     &timeVal,
				PullStoppedAt:     &timeVal,
				StartedAt:         &timeVal,
				StartedBy:         &strVal,
				StopCode:          &strVal,
				StoppedAt:         &timeVal,
				StoppedReason:     &strVal,
				StoppingAt:        &timeVal,
				TaskArn:           strVal,
				TaskDefinitionArn: strVal,
				UpdatedAt:         timeVal,
				Version:           floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.ECSTaskStateChange{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("attachments")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("attributes")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"availabilityZone"`, strVal, "AvailabilityZone")
				requireJmesMatch(t, jsearch, `"clusterArn"`, strVal, "ClusterArn")
				requireJmesMatch(t, jsearch, `"connectivity"`, strVal, "Connectivity")
				requireJmesMatch(t, jsearch, `"connectivityAt"`, string(mustRet(timeVal.MarshalText())), "ConnectivityAt")
				requireJmesMatch(t, jsearch, `"containerInstanceArn"`, strVal, "ContainerInstanceArn")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("containers")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"cpu"`, strVal, "Cpu")
				requireJmesMatch(t, jsearch, `"createdAt"`, string(mustRet(timeVal.MarshalText())), "CreatedAt")
				requireJmesMatch(t, jsearch, `"desiredStatus"`, strVal, "DesiredStatus")
				requireJmesMatch(t, jsearch, `"executionStoppedAt"`, string(mustRet(timeVal.MarshalText())), "ExecutionStoppedAt")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("extraobj")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"group"`, strVal, "Group")
				requireJmesMatch(t, jsearch, `"lastStatus"`, strVal, "LastStatus")
				requireJmesMatch(t, jsearch, `"launchType"`, strVal, "LaunchType")
				requireJmesMatch(t, jsearch, `"memory"`, strVal, "Memory")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("overrides")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"platformVersion"`, strVal, "PlatformVersion")
				requireJmesMatch(t, jsearch, `"pullStartedAt"`, string(mustRet(timeVal.MarshalText())), "PullStartedAt")
				requireJmesMatch(t, jsearch, `"pullStoppedAt"`, string(mustRet(timeVal.MarshalText())), "PullStoppedAt")
				requireJmesMatch(t, jsearch, `"startedAt"`, string(mustRet(timeVal.MarshalText())), "StartedAt")
				requireJmesMatch(t, jsearch, `"startedBy"`, strVal, "StartedBy")
				requireJmesMatch(t, jsearch, `"stopCode"`, strVal, "StopCode")
				requireJmesMatch(t, jsearch, `"stoppedAt"`, string(mustRet(timeVal.MarshalText())), "StoppedAt")
				requireJmesMatch(t, jsearch, `"stoppedReason"`, strVal, "StoppedReason")
				requireJmesMatch(t, jsearch, `"stoppingAt"`, string(mustRet(timeVal.MarshalText())), "StoppingAt")
				requireJmesMatch(t, jsearch, `"taskArn"`, strVal, "TaskArn")
				requireJmesMatch(t, jsearch, `"taskDefinitionArn"`, strVal, "TaskDefinitionArn")
				requireJmesMatch(t, jsearch, `"updatedAt"`, string(mustRet(timeVal.MarshalText())), "UpdatedAt")
				requireJmesMatch(t, jsearch, `"version"`, floatVal, "Version")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.Attachments) // Lazily Tested: everything.ECSTaskStateChange.Attachments == []AttachmentDetails
				require.NotNil(t, genStruct.Attributes)  // Lazily Tested: everything.ECSTaskStateChange.Attributes == []AttributesDetails
				require.Equal(t, strVal, *everything.ECSTaskStateChange{AvailabilityZone: &strVal}.AvailabilityZone)
				require.Equal(t, strVal, everything.ECSTaskStateChange{ClusterArn: strVal}.ClusterArn)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{Connectivity: &strVal}.Connectivity)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{ConnectivityAt: &timeVal}.ConnectivityAt)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{ContainerInstanceArn: &strVal}.ContainerInstanceArn)
				require.NotNil(t, genStruct.Containers) // Lazily Tested: everything.ECSTaskStateChange.Containers == []ContainerDetails
				require.Equal(t, strVal, *everything.ECSTaskStateChange{Cpu: &strVal}.Cpu)
				require.Equal(t, timeVal, everything.ECSTaskStateChange{CreatedAt: timeVal}.CreatedAt)
				require.Equal(t, strVal, everything.ECSTaskStateChange{DesiredStatus: strVal}.DesiredStatus)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{ExecutionStoppedAt: &timeVal}.ExecutionStoppedAt)
				require.NotNil(t, genStruct.Extraobj) // Lazily Tested: everything.ECSTaskStateChange.Extraobj == *ExtraWithStrings
				require.Equal(t, strVal, *everything.ECSTaskStateChange{Group: &strVal}.Group)
				require.Equal(t, strVal, everything.ECSTaskStateChange{LastStatus: strVal}.LastStatus)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{LaunchType: &strVal}.LaunchType)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{Memory: &strVal}.Memory)
				require.NotNil(t, genStruct.Overrides) // Lazily Tested: everything.ECSTaskStateChange.Overrides == *Overrides
				require.Equal(t, strVal, *everything.ECSTaskStateChange{PlatformVersion: &strVal}.PlatformVersion)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{PullStartedAt: &timeVal}.PullStartedAt)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{PullStoppedAt: &timeVal}.PullStoppedAt)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{StartedAt: &timeVal}.StartedAt)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{StartedBy: &strVal}.StartedBy)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{StopCode: &strVal}.StopCode)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{StoppedAt: &timeVal}.StoppedAt)
				require.Equal(t, strVal, *everything.ECSTaskStateChange{StoppedReason: &strVal}.StoppedReason)
				require.Equal(t, timeVal, *everything.ECSTaskStateChange{StoppingAt: &timeVal}.StoppingAt)
				require.Equal(t, strVal, everything.ECSTaskStateChange{TaskArn: strVal}.TaskArn)
				require.Equal(t, strVal, everything.ECSTaskStateChange{TaskDefinitionArn: strVal}.TaskDefinitionArn)
				require.Equal(t, timeVal, everything.ECSTaskStateChange{UpdatedAt: timeVal}.UpdatedAt)
				require.Equal(t, floatVal, everything.ECSTaskStateChange{Version: floatVal}.Version)
			})
		})

		t.Run("ExtraWithStrings", func(t *testing.T) {
			genStruct := &everything.ExtraWithStrings{
				AdditionalProperties: map[string]string{
					strVal: strVal,
				},
				Somenum:  &floatVal,
				Someprop: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.ExtraWithStrings{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"somenum"`, floatVal, "Somenum")
				requireJmesMatch(t, jsearch, `"someprop"`, strVal, "Someprop")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.AdditionalProperties) // Lazily Tested: everything.ExtraWithStrings.AdditionalProperties == map[string]string
				require.Equal(t, floatVal, *everything.ExtraWithStrings{Somenum: &floatVal}.Somenum)
				require.Equal(t, strVal, *everything.ExtraWithStrings{Someprop: &strVal}.Someprop)
			})
		})

		t.Run("NetworkBindingDetails", func(t *testing.T) {
			genStruct := &everything.NetworkBindingDetails{
				BindIP:        &strVal,
				ContainerPort: &floatVal,
				HostPort:      &floatVal,
				Protocol:      &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.NetworkBindingDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"bindIP"`, strVal, "BindIP")
				requireJmesMatch(t, jsearch, `"containerPort"`, floatVal, "ContainerPort")
				requireJmesMatch(t, jsearch, `"hostPort"`, floatVal, "HostPort")
				requireJmesMatch(t, jsearch, `"protocol"`, strVal, "Protocol")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *everything.NetworkBindingDetails{BindIP: &strVal}.BindIP)
				require.Equal(t, floatVal, *everything.NetworkBindingDetails{ContainerPort: &floatVal}.ContainerPort)
				require.Equal(t, floatVal, *everything.NetworkBindingDetails{HostPort: &floatVal}.HostPort)
				require.Equal(t, strVal, *everything.NetworkBindingDetails{Protocol: &strVal}.Protocol)
			})
		})

		t.Run("NetworkInterfaceDetails", func(t *testing.T) {
			genStruct := &everything.NetworkInterfaceDetails{
				AttachmentId:       &strVal,
				Ipv6Address:        &strVal,
				PrivateIpv4Address: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.NetworkInterfaceDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"attachmentId"`, strVal, "AttachmentId")
				requireJmesMatch(t, jsearch, `"ipv6Address"`, strVal, "Ipv6Address")
				requireJmesMatch(t, jsearch, `"privateIpv4Address"`, strVal, "PrivateIpv4Address")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *everything.NetworkInterfaceDetails{AttachmentId: &strVal}.AttachmentId)
				require.Equal(t, strVal, *everything.NetworkInterfaceDetails{Ipv6Address: &strVal}.Ipv6Address)
				require.Equal(t, strVal, *everything.NetworkInterfaceDetails{PrivateIpv4Address: &strVal}.PrivateIpv4Address)
			})
		})

		t.Run("Overrides", func(t *testing.T) {
			genStruct := &everything.Overrides{
				ContainerOverrides: []everything.OverridesItem{{
					Command: []string{strVal},
					Cpu:     &floatVal,
					Environment: []everything.Environment{map[string]string{
						strVal: strVal,
					}},
					Memory: &floatVal,
					Name:   strVal,
				}},
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.Overrides{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("containerOverrides")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.ContainerOverrides) // Lazily Tested: everything.Overrides.ContainerOverrides == []OverridesItem
			})
		})

		t.Run("OverridesItem", func(t *testing.T) {
			genStruct := &everything.OverridesItem{
				Command: []string{strVal},
				Cpu:     &floatVal,
				Environment: []everything.Environment{map[string]string{
					strVal: strVal,
				}},
				Memory: &floatVal,
				Name:   strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.OverridesItem{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("command")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"cpu"`, floatVal, "Cpu")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("environment")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"memory"`, floatVal, "Memory")
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")

			})
			t.Run("fields", func(t *testing.T) {
				require.Contains(t, everything.OverridesItem{Command: []string{strVal}}.Command, strVal)
				require.Equal(t, floatVal, *everything.OverridesItem{Cpu: &floatVal}.Cpu)
				require.NotNil(t, genStruct.Environment) // Lazily Tested: everything.OverridesItem.Environment == []Environment
				require.Equal(t, floatVal, *everything.OverridesItem{Memory: &floatVal}.Memory)
				require.Equal(t, strVal, everything.OverridesItem{Name: strVal}.Name)
			})
		})

		t.Run("RecoveryGroupStatusChange", func(t *testing.T) {
			genStruct := &everything.RecoveryGroupStatusChange{
				NewState: &everything.State{
					ReadinessStatus: everything.ReadinessStatusType("FAKE"),
				},
				PreviousState: &everything.State{
					ReadinessStatus: everything.ReadinessStatusType("FAKE"),
				},
				RecoveryGroupName: strVal,
				Taskchange: &everything.ECSTaskStateChange{
					Attachments: []everything.AttachmentDetails{{
						Details: &everything.Details{
							Name:  &strVal,
							Value: &strVal,
						},
						Id:     &strVal,
						Status: &strVal,
						Type:   &strVal,
					}},
					Attributes: []everything.AttributesDetails{{
						Name:  &strVal,
						Value: &strVal,
					}},
					AvailabilityZone:     &strVal,
					ClusterArn:           strVal,
					Connectivity:         &strVal,
					ConnectivityAt:       &timeVal,
					ContainerInstanceArn: &strVal,
					Containers: []everything.ContainerDetails{{
						ContainerArn:      strVal,
						Cpu:               &strVal,
						ExitCode:          &floatVal,
						GpuIds:            []string{strVal},
						Image:             &strVal,
						ImageDigest:       &strVal,
						LastStatus:        strVal,
						Memory:            &strVal,
						MemoryReservation: &strVal,
						Name:              strVal,
						NetworkBindings: []everything.NetworkBindingDetails{{
							BindIP:        &strVal,
							ContainerPort: &floatVal,
							HostPort:      &floatVal,
							Protocol:      &strVal,
						}},
						NetworkInterfaces: []everything.NetworkInterfaceDetails{{
							AttachmentId:       &strVal,
							Ipv6Address:        &strVal,
							PrivateIpv4Address: &strVal,
						}},
						Reason:    &strVal,
						RuntimeId: &strVal,
						TaskArn:   strVal,
					}},
					Cpu:                &strVal,
					CreatedAt:          timeVal,
					DesiredStatus:      strVal,
					ExecutionStoppedAt: &timeVal,
					Extraobj: &everything.ExtraWithStrings{
						AdditionalProperties: map[string]string{
							strVal: strVal,
						},
						Somenum:  &floatVal,
						Someprop: &strVal,
					},
					Group:      &strVal,
					LastStatus: strVal,
					LaunchType: &strVal,
					Memory:     &strVal,
					Overrides: &everything.Overrides{
						ContainerOverrides: []everything.OverridesItem{{
							Command: []string{strVal},
							Cpu:     &floatVal,
							Environment: []everything.Environment{map[string]string{
								strVal: strVal,
							}},
							Memory: &floatVal,
							Name:   strVal,
						}},
					},
					PlatformVersion:   &strVal,
					PullStartedAt:     &timeVal,
					PullStoppedAt:     &timeVal,
					StartedAt:         &timeVal,
					StartedBy:         &strVal,
					StopCode:          &strVal,
					StoppedAt:         &timeVal,
					StoppedReason:     &strVal,
					StoppingAt:        &timeVal,
					TaskArn:           strVal,
					TaskDefinitionArn: strVal,
					UpdatedAt:         timeVal,
					Version:           floatVal,
				},
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.RecoveryGroupStatusChange{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("new-state")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("previous-state")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"recovery-group-name"`, strVal, "RecoveryGroupName")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("taskchange")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.NewState)      // Lazily Tested: everything.RecoveryGroupStatusChange.NewState == *State
				require.NotNil(t, genStruct.PreviousState) // Lazily Tested: everything.RecoveryGroupStatusChange.PreviousState == *State
				require.Equal(t, strVal, everything.RecoveryGroupStatusChange{RecoveryGroupName: strVal}.RecoveryGroupName)
				require.NotNil(t, genStruct.Taskchange) // Lazily Tested: everything.RecoveryGroupStatusChange.Taskchange == *ECSTaskStateChange
			})
		})

		t.Run("Root", func(t *testing.T) {
			genStruct := &everything.Root{
				Account: strVal,
				Detail: &everything.RecoveryGroupStatusChange{
					NewState: &everything.State{
						ReadinessStatus: everything.ReadinessStatusType("FAKE"),
					},
					PreviousState: &everything.State{
						ReadinessStatus: everything.ReadinessStatusType("FAKE"),
					},
					RecoveryGroupName: strVal,
					Taskchange: &everything.ECSTaskStateChange{
						Attachments: []everything.AttachmentDetails{{
							Details: &everything.Details{
								Name:  &strVal,
								Value: &strVal,
							},
							Id:     &strVal,
							Status: &strVal,
							Type:   &strVal,
						}},
						Attributes: []everything.AttributesDetails{{
							Name:  &strVal,
							Value: &strVal,
						}},
						AvailabilityZone:     &strVal,
						ClusterArn:           strVal,
						Connectivity:         &strVal,
						ConnectivityAt:       &timeVal,
						ContainerInstanceArn: &strVal,
						Containers: []everything.ContainerDetails{{
							ContainerArn:      strVal,
							Cpu:               &strVal,
							ExitCode:          &floatVal,
							GpuIds:            []string{strVal},
							Image:             &strVal,
							ImageDigest:       &strVal,
							LastStatus:        strVal,
							Memory:            &strVal,
							MemoryReservation: &strVal,
							Name:              strVal,
							NetworkBindings: []everything.NetworkBindingDetails{{
								BindIP:        &strVal,
								ContainerPort: &floatVal,
								HostPort:      &floatVal,
								Protocol:      &strVal,
							}},
							NetworkInterfaces: []everything.NetworkInterfaceDetails{{
								AttachmentId:       &strVal,
								Ipv6Address:        &strVal,
								PrivateIpv4Address: &strVal,
							}},
							Reason:    &strVal,
							RuntimeId: &strVal,
							TaskArn:   strVal,
						}},
						Cpu:                &strVal,
						CreatedAt:          timeVal,
						DesiredStatus:      strVal,
						ExecutionStoppedAt: &timeVal,
						Extraobj: &everything.ExtraWithStrings{
							AdditionalProperties: map[string]string{
								strVal: strVal,
							},
							Somenum:  &floatVal,
							Someprop: &strVal,
						},
						Group:      &strVal,
						LastStatus: strVal,
						LaunchType: &strVal,
						Memory:     &strVal,
						Overrides: &everything.Overrides{
							ContainerOverrides: []everything.OverridesItem{{
								Command: []string{strVal},
								Cpu:     &floatVal,
								Environment: []everything.Environment{map[string]string{
									strVal: strVal,
								}},
								Memory: &floatVal,
								Name:   strVal,
							}},
						},
						PlatformVersion:   &strVal,
						PullStartedAt:     &timeVal,
						PullStoppedAt:     &timeVal,
						StartedAt:         &timeVal,
						StartedBy:         &strVal,
						StopCode:          &strVal,
						StoppedAt:         &timeVal,
						StoppedReason:     &strVal,
						StoppingAt:        &timeVal,
						TaskArn:           strVal,
						TaskDefinitionArn: strVal,
						UpdatedAt:         timeVal,
						Version:           floatVal,
					},
				},
				DetailType: strVal,
				Id:         strVal,
				Region:     strVal,
				Resources:  []string{strVal},
				Source:     strVal,
				Time:       timeVal,
				Version:    strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.Root{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"account"`, strVal, "Account")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("detail")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"detail-type"`, strVal, "DetailType")
				requireJmesMatch(t, jsearch, `"id"`, strVal, "Id")
				requireJmesMatch(t, jsearch, `"region"`, strVal, "Region")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("resources")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"source"`, strVal, "Source")
				requireJmesMatch(t, jsearch, `"time"`, string(mustRet(timeVal.MarshalText())), "Time")
				requireJmesMatch(t, jsearch, `"version"`, strVal, "Version")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, everything.Root{Account: strVal}.Account)
				require.NotNil(t, genStruct.Detail) // Lazily Tested: everything.Root.Detail == *RecoveryGroupStatusChange
				require.Equal(t, strVal, everything.Root{DetailType: strVal}.DetailType)
				require.Equal(t, strVal, everything.Root{Id: strVal}.Id)
				require.Equal(t, strVal, everything.Root{Region: strVal}.Region)
				require.Contains(t, everything.Root{Resources: []string{strVal}}.Resources, strVal)
				require.Equal(t, strVal, everything.Root{Source: strVal}.Source)
				require.Equal(t, timeVal, everything.Root{Time: timeVal}.Time)
				require.Equal(t, strVal, everything.Root{Version: strVal}.Version)
			})
		})

		t.Run("State", func(t *testing.T) {
			genStruct := &everything.State{
				ReadinessStatus: everything.ReadinessStatusType("FAKE"),
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &everything.State{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("readiness-status")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.ReadinessStatus) // Lazily Tested: everything.State.ReadinessStatus == ReadinessStatusType
			})
		})

	})

}
