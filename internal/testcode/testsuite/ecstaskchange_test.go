// Code generated by awseventgenerator/internal/generators/testcode. DO NOT EDIT.

package testsuitegenerated

import (
	"encoding/json"
	"github.com/stretchr/testify/require"
	"testing"
	"time"

	ecstaskchange "github.com/webdestroya/awseventgenerator/internal/testcode/ecstaskchange_gen"
)

func TestGenerated_ecstaskchange(t *testing.T) {

	strVal := "someString"
	floatVal := float64(1232.1424)
	intVal := int64(1232)
	timeVal := time.Now().UTC()
	trueVal := true
	anyVal := struct {
		Thing string `json:"thinger"`
	}{Thing: "anywayanyday"}

	require.IsType(t, *new(string), strVal)
	require.IsType(t, *new(float64), floatVal)
	require.IsType(t, *new(int64), intVal)
	require.IsType(t, *new(time.Time), timeVal)
	require.IsType(t, *new(bool), trueVal)
	_ = anyVal

	t.Run("constants", func(t *testing.T) {
		require.Equal(t, `ECS Task State Change`, ecstaskchange.AwsEventDetailType)
		require.Equal(t, `aws.ecs`, ecstaskchange.AwsEventSource)
	})

	t.Run("aliases", func(t *testing.T) {
		require.IsType(t, *new(map[string]string), *new(ecstaskchange.Environment))
	})

	t.Run("structs", func(t *testing.T) {
		t.Run("AttachmentDetails", func(t *testing.T) {
			genStruct := &ecstaskchange.AttachmentDetails{
				Details: &ecstaskchange.Details{
					Name:  &strVal,
					Value: &strVal,
				},
				Id:     &strVal,
				Status: &strVal,
				Type:   &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.AttachmentDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("details")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"id"`, strVal, "Id")
				requireJmesMatch(t, jsearch, `"status"`, strVal, "Status")
				requireJmesMatch(t, jsearch, `"type"`, strVal, "Type")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.Details) // Lazily Tested: ecstaskchange.AttachmentDetails.Details == *Details
				require.Equal(t, strVal, *ecstaskchange.AttachmentDetails{Id: &strVal}.Id)
				require.Equal(t, strVal, *ecstaskchange.AttachmentDetails{Status: &strVal}.Status)
				require.Equal(t, strVal, *ecstaskchange.AttachmentDetails{Type: &strVal}.Type)
			})
		})

		t.Run("AttributesDetails", func(t *testing.T) {
			genStruct := &ecstaskchange.AttributesDetails{
				Name:  &strVal,
				Value: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.AttributesDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				requireJmesMatch(t, jsearch, `"value"`, strVal, "Value")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *ecstaskchange.AttributesDetails{Name: &strVal}.Name)
				require.Equal(t, strVal, *ecstaskchange.AttributesDetails{Value: &strVal}.Value)
			})
		})

		t.Run("ContainerDetails", func(t *testing.T) {
			genStruct := &ecstaskchange.ContainerDetails{
				ContainerArn:      strVal,
				Cpu:               &strVal,
				ExitCode:          &floatVal,
				GpuIds:            []string{strVal},
				Image:             &strVal,
				ImageDigest:       &strVal,
				LastStatus:        strVal,
				Memory:            &strVal,
				MemoryReservation: &strVal,
				Name:              strVal,
				NetworkBindings: []ecstaskchange.NetworkBindingDetails{{
					BindIP:        &strVal,
					ContainerPort: &floatVal,
					HostPort:      &floatVal,
					Protocol:      &strVal,
				}},
				NetworkInterfaces: []ecstaskchange.NetworkInterfaceDetails{{
					AttachmentId:       &strVal,
					Ipv6Address:        &strVal,
					PrivateIpv4Address: &strVal,
				}},
				Reason:    &strVal,
				RuntimeId: &strVal,
				TaskArn:   strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.ContainerDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"containerArn"`, strVal, "ContainerArn")
				requireJmesMatch(t, jsearch, `"cpu"`, strVal, "Cpu")
				requireJmesMatch(t, jsearch, `"exitCode"`, floatVal, "ExitCode")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("gpuIds")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"image"`, strVal, "Image")
				requireJmesMatch(t, jsearch, `"imageDigest"`, strVal, "ImageDigest")
				requireJmesMatch(t, jsearch, `"lastStatus"`, strVal, "LastStatus")
				requireJmesMatch(t, jsearch, `"memory"`, strVal, "Memory")
				requireJmesMatch(t, jsearch, `"memoryReservation"`, strVal, "MemoryReservation")
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("networkBindings")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("networkInterfaces")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"reason"`, strVal, "Reason")
				requireJmesMatch(t, jsearch, `"runtimeId"`, strVal, "RuntimeId")
				requireJmesMatch(t, jsearch, `"taskArn"`, strVal, "TaskArn")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, ecstaskchange.ContainerDetails{ContainerArn: strVal}.ContainerArn)
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{Cpu: &strVal}.Cpu)
				require.Equal(t, floatVal, *ecstaskchange.ContainerDetails{ExitCode: &floatVal}.ExitCode)
				require.Contains(t, ecstaskchange.ContainerDetails{GpuIds: []string{strVal}}.GpuIds, strVal)
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{Image: &strVal}.Image)
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{ImageDigest: &strVal}.ImageDigest)
				require.Equal(t, strVal, ecstaskchange.ContainerDetails{LastStatus: strVal}.LastStatus)
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{Memory: &strVal}.Memory)
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{MemoryReservation: &strVal}.MemoryReservation)
				require.Equal(t, strVal, ecstaskchange.ContainerDetails{Name: strVal}.Name)
				require.NotNil(t, genStruct.NetworkBindings)   // Lazily Tested: ecstaskchange.ContainerDetails.NetworkBindings == []NetworkBindingDetails
				require.NotNil(t, genStruct.NetworkInterfaces) // Lazily Tested: ecstaskchange.ContainerDetails.NetworkInterfaces == []NetworkInterfaceDetails
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{Reason: &strVal}.Reason)
				require.Equal(t, strVal, *ecstaskchange.ContainerDetails{RuntimeId: &strVal}.RuntimeId)
				require.Equal(t, strVal, ecstaskchange.ContainerDetails{TaskArn: strVal}.TaskArn)
			})
		})

		t.Run("Details", func(t *testing.T) {
			genStruct := &ecstaskchange.Details{
				Name:  &strVal,
				Value: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.Details{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				requireJmesMatch(t, jsearch, `"value"`, strVal, "Value")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *ecstaskchange.Details{Name: &strVal}.Name)
				require.Equal(t, strVal, *ecstaskchange.Details{Value: &strVal}.Value)
			})
		})

		t.Run("ECSTaskStateChange", func(t *testing.T) {
			genStruct := &ecstaskchange.ECSTaskStateChange{
				Attachments: []ecstaskchange.AttachmentDetails{{
					Details: &ecstaskchange.Details{
						Name:  &strVal,
						Value: &strVal,
					},
					Id:     &strVal,
					Status: &strVal,
					Type:   &strVal,
				}},
				Attributes: []ecstaskchange.AttributesDetails{{
					Name:  &strVal,
					Value: &strVal,
				}},
				AvailabilityZone:     &strVal,
				ClusterArn:           strVal,
				Connectivity:         &strVal,
				ConnectivityAt:       &timeVal,
				ContainerInstanceArn: &strVal,
				Containers: []ecstaskchange.ContainerDetails{{
					ContainerArn:      strVal,
					Cpu:               &strVal,
					ExitCode:          &floatVal,
					GpuIds:            []string{strVal},
					Image:             &strVal,
					ImageDigest:       &strVal,
					LastStatus:        strVal,
					Memory:            &strVal,
					MemoryReservation: &strVal,
					Name:              strVal,
					NetworkBindings: []ecstaskchange.NetworkBindingDetails{{
						BindIP:        &strVal,
						ContainerPort: &floatVal,
						HostPort:      &floatVal,
						Protocol:      &strVal,
					}},
					NetworkInterfaces: []ecstaskchange.NetworkInterfaceDetails{{
						AttachmentId:       &strVal,
						Ipv6Address:        &strVal,
						PrivateIpv4Address: &strVal,
					}},
					Reason:    &strVal,
					RuntimeId: &strVal,
					TaskArn:   strVal,
				}},
				Cpu:                &strVal,
				CreatedAt:          timeVal,
				DesiredStatus:      strVal,
				ExecutionStoppedAt: &timeVal,
				Group:              &strVal,
				LastStatus:         strVal,
				LaunchType:         &strVal,
				Memory:             &strVal,
				Overrides: &ecstaskchange.Overrides{
					ContainerOverrides: []ecstaskchange.OverridesItem{{
						Command: []string{strVal},
						Cpu:     &floatVal,
						Environment: []ecstaskchange.Environment{map[string]string{
							strVal: strVal,
						}},
						Memory: &floatVal,
						Name:   strVal,
					}},
				},
				PlatformVersion:   &strVal,
				PullStartedAt:     &timeVal,
				PullStoppedAt:     &timeVal,
				StartedAt:         &timeVal,
				StartedBy:         &strVal,
				StopCode:          &strVal,
				StoppedAt:         &timeVal,
				StoppedReason:     &strVal,
				StoppingAt:        &timeVal,
				TaskArn:           strVal,
				TaskDefinitionArn: strVal,
				UpdatedAt:         timeVal,
				Version:           floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.ECSTaskStateChange{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("attachments")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("attributes")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"availabilityZone"`, strVal, "AvailabilityZone")
				requireJmesMatch(t, jsearch, `"clusterArn"`, strVal, "ClusterArn")
				requireJmesMatch(t, jsearch, `"connectivity"`, strVal, "Connectivity")
				requireJmesMatch(t, jsearch, `"connectivityAt"`, string(mustRet(timeVal.MarshalText())), "ConnectivityAt")
				requireJmesMatch(t, jsearch, `"containerInstanceArn"`, strVal, "ContainerInstanceArn")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("containers")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"cpu"`, strVal, "Cpu")
				requireJmesMatch(t, jsearch, `"createdAt"`, string(mustRet(timeVal.MarshalText())), "CreatedAt")
				requireJmesMatch(t, jsearch, `"desiredStatus"`, strVal, "DesiredStatus")
				requireJmesMatch(t, jsearch, `"executionStoppedAt"`, string(mustRet(timeVal.MarshalText())), "ExecutionStoppedAt")
				requireJmesMatch(t, jsearch, `"group"`, strVal, "Group")
				requireJmesMatch(t, jsearch, `"lastStatus"`, strVal, "LastStatus")
				requireJmesMatch(t, jsearch, `"launchType"`, strVal, "LaunchType")
				requireJmesMatch(t, jsearch, `"memory"`, strVal, "Memory")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("overrides")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"platformVersion"`, strVal, "PlatformVersion")
				requireJmesMatch(t, jsearch, `"pullStartedAt"`, string(mustRet(timeVal.MarshalText())), "PullStartedAt")
				requireJmesMatch(t, jsearch, `"pullStoppedAt"`, string(mustRet(timeVal.MarshalText())), "PullStoppedAt")
				requireJmesMatch(t, jsearch, `"startedAt"`, string(mustRet(timeVal.MarshalText())), "StartedAt")
				requireJmesMatch(t, jsearch, `"startedBy"`, strVal, "StartedBy")
				requireJmesMatch(t, jsearch, `"stopCode"`, strVal, "StopCode")
				requireJmesMatch(t, jsearch, `"stoppedAt"`, string(mustRet(timeVal.MarshalText())), "StoppedAt")
				requireJmesMatch(t, jsearch, `"stoppedReason"`, strVal, "StoppedReason")
				requireJmesMatch(t, jsearch, `"stoppingAt"`, string(mustRet(timeVal.MarshalText())), "StoppingAt")
				requireJmesMatch(t, jsearch, `"taskArn"`, strVal, "TaskArn")
				requireJmesMatch(t, jsearch, `"taskDefinitionArn"`, strVal, "TaskDefinitionArn")
				requireJmesMatch(t, jsearch, `"updatedAt"`, string(mustRet(timeVal.MarshalText())), "UpdatedAt")
				requireJmesMatch(t, jsearch, `"version"`, floatVal, "Version")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.Attachments) // Lazily Tested: ecstaskchange.ECSTaskStateChange.Attachments == []AttachmentDetails
				require.NotNil(t, genStruct.Attributes)  // Lazily Tested: ecstaskchange.ECSTaskStateChange.Attributes == []AttributesDetails
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{AvailabilityZone: &strVal}.AvailabilityZone)
				require.Equal(t, strVal, ecstaskchange.ECSTaskStateChange{ClusterArn: strVal}.ClusterArn)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{Connectivity: &strVal}.Connectivity)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{ConnectivityAt: &timeVal}.ConnectivityAt)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{ContainerInstanceArn: &strVal}.ContainerInstanceArn)
				require.NotNil(t, genStruct.Containers) // Lazily Tested: ecstaskchange.ECSTaskStateChange.Containers == []ContainerDetails
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{Cpu: &strVal}.Cpu)
				require.Equal(t, timeVal, ecstaskchange.ECSTaskStateChange{CreatedAt: timeVal}.CreatedAt)
				require.Equal(t, strVal, ecstaskchange.ECSTaskStateChange{DesiredStatus: strVal}.DesiredStatus)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{ExecutionStoppedAt: &timeVal}.ExecutionStoppedAt)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{Group: &strVal}.Group)
				require.Equal(t, strVal, ecstaskchange.ECSTaskStateChange{LastStatus: strVal}.LastStatus)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{LaunchType: &strVal}.LaunchType)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{Memory: &strVal}.Memory)
				require.NotNil(t, genStruct.Overrides) // Lazily Tested: ecstaskchange.ECSTaskStateChange.Overrides == *Overrides
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{PlatformVersion: &strVal}.PlatformVersion)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{PullStartedAt: &timeVal}.PullStartedAt)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{PullStoppedAt: &timeVal}.PullStoppedAt)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{StartedAt: &timeVal}.StartedAt)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{StartedBy: &strVal}.StartedBy)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{StopCode: &strVal}.StopCode)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{StoppedAt: &timeVal}.StoppedAt)
				require.Equal(t, strVal, *ecstaskchange.ECSTaskStateChange{StoppedReason: &strVal}.StoppedReason)
				require.Equal(t, timeVal, *ecstaskchange.ECSTaskStateChange{StoppingAt: &timeVal}.StoppingAt)
				require.Equal(t, strVal, ecstaskchange.ECSTaskStateChange{TaskArn: strVal}.TaskArn)
				require.Equal(t, strVal, ecstaskchange.ECSTaskStateChange{TaskDefinitionArn: strVal}.TaskDefinitionArn)
				require.Equal(t, timeVal, ecstaskchange.ECSTaskStateChange{UpdatedAt: timeVal}.UpdatedAt)
				require.Equal(t, floatVal, ecstaskchange.ECSTaskStateChange{Version: floatVal}.Version)
			})
		})

		t.Run("NetworkBindingDetails", func(t *testing.T) {
			genStruct := &ecstaskchange.NetworkBindingDetails{
				BindIP:        &strVal,
				ContainerPort: &floatVal,
				HostPort:      &floatVal,
				Protocol:      &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.NetworkBindingDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"bindIP"`, strVal, "BindIP")
				requireJmesMatch(t, jsearch, `"containerPort"`, floatVal, "ContainerPort")
				requireJmesMatch(t, jsearch, `"hostPort"`, floatVal, "HostPort")
				requireJmesMatch(t, jsearch, `"protocol"`, strVal, "Protocol")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *ecstaskchange.NetworkBindingDetails{BindIP: &strVal}.BindIP)
				require.Equal(t, floatVal, *ecstaskchange.NetworkBindingDetails{ContainerPort: &floatVal}.ContainerPort)
				require.Equal(t, floatVal, *ecstaskchange.NetworkBindingDetails{HostPort: &floatVal}.HostPort)
				require.Equal(t, strVal, *ecstaskchange.NetworkBindingDetails{Protocol: &strVal}.Protocol)
			})
		})

		t.Run("NetworkInterfaceDetails", func(t *testing.T) {
			genStruct := &ecstaskchange.NetworkInterfaceDetails{
				AttachmentId:       &strVal,
				Ipv6Address:        &strVal,
				PrivateIpv4Address: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.NetworkInterfaceDetails{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"attachmentId"`, strVal, "AttachmentId")
				requireJmesMatch(t, jsearch, `"ipv6Address"`, strVal, "Ipv6Address")
				requireJmesMatch(t, jsearch, `"privateIpv4Address"`, strVal, "PrivateIpv4Address")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *ecstaskchange.NetworkInterfaceDetails{AttachmentId: &strVal}.AttachmentId)
				require.Equal(t, strVal, *ecstaskchange.NetworkInterfaceDetails{Ipv6Address: &strVal}.Ipv6Address)
				require.Equal(t, strVal, *ecstaskchange.NetworkInterfaceDetails{PrivateIpv4Address: &strVal}.PrivateIpv4Address)
			})
		})

		t.Run("Overrides", func(t *testing.T) {
			genStruct := &ecstaskchange.Overrides{
				ContainerOverrides: []ecstaskchange.OverridesItem{{
					Command: []string{strVal},
					Cpu:     &floatVal,
					Environment: []ecstaskchange.Environment{map[string]string{
						strVal: strVal,
					}},
					Memory: &floatVal,
					Name:   strVal,
				}},
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.Overrides{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("containerOverrides")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.ContainerOverrides) // Lazily Tested: ecstaskchange.Overrides.ContainerOverrides == []OverridesItem
			})
		})

		t.Run("OverridesItem", func(t *testing.T) {
			genStruct := &ecstaskchange.OverridesItem{
				Command: []string{strVal},
				Cpu:     &floatVal,
				Environment: []ecstaskchange.Environment{map[string]string{
					strVal: strVal,
				}},
				Memory: &floatVal,
				Name:   strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.OverridesItem{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("command")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"cpu"`, floatVal, "Cpu")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("environment")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"memory"`, floatVal, "Memory")
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")

			})
			t.Run("fields", func(t *testing.T) {
				require.Contains(t, ecstaskchange.OverridesItem{Command: []string{strVal}}.Command, strVal)
				require.Equal(t, floatVal, *ecstaskchange.OverridesItem{Cpu: &floatVal}.Cpu)
				require.NotNil(t, genStruct.Environment) // Lazily Tested: ecstaskchange.OverridesItem.Environment == []Environment
				require.Equal(t, floatVal, *ecstaskchange.OverridesItem{Memory: &floatVal}.Memory)
				require.Equal(t, strVal, ecstaskchange.OverridesItem{Name: strVal}.Name)
			})
		})

		t.Run("Root", func(t *testing.T) {
			genStruct := &ecstaskchange.Root{
				Account: strVal,
				Detail: &ecstaskchange.ECSTaskStateChange{
					Attachments: []ecstaskchange.AttachmentDetails{{
						Details: &ecstaskchange.Details{
							Name:  &strVal,
							Value: &strVal,
						},
						Id:     &strVal,
						Status: &strVal,
						Type:   &strVal,
					}},
					Attributes: []ecstaskchange.AttributesDetails{{
						Name:  &strVal,
						Value: &strVal,
					}},
					AvailabilityZone:     &strVal,
					ClusterArn:           strVal,
					Connectivity:         &strVal,
					ConnectivityAt:       &timeVal,
					ContainerInstanceArn: &strVal,
					Containers: []ecstaskchange.ContainerDetails{{
						ContainerArn:      strVal,
						Cpu:               &strVal,
						ExitCode:          &floatVal,
						GpuIds:            []string{strVal},
						Image:             &strVal,
						ImageDigest:       &strVal,
						LastStatus:        strVal,
						Memory:            &strVal,
						MemoryReservation: &strVal,
						Name:              strVal,
						NetworkBindings: []ecstaskchange.NetworkBindingDetails{{
							BindIP:        &strVal,
							ContainerPort: &floatVal,
							HostPort:      &floatVal,
							Protocol:      &strVal,
						}},
						NetworkInterfaces: []ecstaskchange.NetworkInterfaceDetails{{
							AttachmentId:       &strVal,
							Ipv6Address:        &strVal,
							PrivateIpv4Address: &strVal,
						}},
						Reason:    &strVal,
						RuntimeId: &strVal,
						TaskArn:   strVal,
					}},
					Cpu:                &strVal,
					CreatedAt:          timeVal,
					DesiredStatus:      strVal,
					ExecutionStoppedAt: &timeVal,
					Group:              &strVal,
					LastStatus:         strVal,
					LaunchType:         &strVal,
					Memory:             &strVal,
					Overrides: &ecstaskchange.Overrides{
						ContainerOverrides: []ecstaskchange.OverridesItem{{
							Command: []string{strVal},
							Cpu:     &floatVal,
							Environment: []ecstaskchange.Environment{map[string]string{
								strVal: strVal,
							}},
							Memory: &floatVal,
							Name:   strVal,
						}},
					},
					PlatformVersion:   &strVal,
					PullStartedAt:     &timeVal,
					PullStoppedAt:     &timeVal,
					StartedAt:         &timeVal,
					StartedBy:         &strVal,
					StopCode:          &strVal,
					StoppedAt:         &timeVal,
					StoppedReason:     &strVal,
					StoppingAt:        &timeVal,
					TaskArn:           strVal,
					TaskDefinitionArn: strVal,
					UpdatedAt:         timeVal,
					Version:           floatVal,
				},
				DetailType: strVal,
				Id:         strVal,
				Region:     strVal,
				Resources:  []string{strVal},
				Source:     strVal,
				Time:       timeVal,
				Version:    strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &ecstaskchange.Root{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"account"`, strVal, "Account")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("detail")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"detail-type"`, strVal, "DetailType")
				requireJmesMatch(t, jsearch, `"id"`, strVal, "Id")
				requireJmesMatch(t, jsearch, `"region"`, strVal, "Region")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("resources")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"source"`, strVal, "Source")
				requireJmesMatch(t, jsearch, `"time"`, string(mustRet(timeVal.MarshalText())), "Time")
				requireJmesMatch(t, jsearch, `"version"`, strVal, "Version")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, ecstaskchange.Root{Account: strVal}.Account)
				require.NotNil(t, genStruct.Detail) // Lazily Tested: ecstaskchange.Root.Detail == *ECSTaskStateChange
				require.Equal(t, strVal, ecstaskchange.Root{DetailType: strVal}.DetailType)
				require.Equal(t, strVal, ecstaskchange.Root{Id: strVal}.Id)
				require.Equal(t, strVal, ecstaskchange.Root{Region: strVal}.Region)
				require.Contains(t, ecstaskchange.Root{Resources: []string{strVal}}.Resources, strVal)
				require.Equal(t, strVal, ecstaskchange.Root{Source: strVal}.Source)
				require.Equal(t, timeVal, ecstaskchange.Root{Time: timeVal}.Time)
				require.Equal(t, strVal, ecstaskchange.Root{Version: strVal}.Version)
			})
		})

	})

}
