// Code generated by awseventgenerator/internal/generators/testcode. DO NOT EDIT.

package testsuitegenerated

import (
	"encoding/json"
	"github.com/stretchr/testify/require"
	"testing"
	"time"

	test "github.com/webdestroya/awseventgenerator/internal/testcode/test_gen"
)

func TestGenerated_test(t *testing.T) {

	strVal := "someString"
	floatVal := float64(1232.1424)
	intVal := int64(1232)
	timeVal := time.Now().UTC()
	trueVal := true
	anyVal := struct {
		Thing string `json:"thinger"`
	}{Thing: "anywayanyday"}

	require.IsType(t, *new(string), strVal)
	require.IsType(t, *new(float64), floatVal)
	require.IsType(t, *new(int64), intVal)
	require.IsType(t, *new(time.Time), timeVal)
	require.IsType(t, *new(bool), trueVal)
	_ = anyVal

	t.Run("enums", func(t *testing.T) {
		t.Run("FavouritecatType", func(t *testing.T) {
			require.Equal(t, "A", string(test.FavouritecatTypeA))
			require.Contains(t, test.FavouritecatTypeA.Values(), test.FavouritecatTypeA)

			require.Equal(t, "B", string(test.FavouritecatTypeB))
			require.Contains(t, test.FavouritecatTypeB.Values(), test.FavouritecatTypeB)

			require.Equal(t, "C", string(test.FavouritecatTypeC))
			require.Contains(t, test.FavouritecatTypeC.Values(), test.FavouritecatTypeC)

			require.Equal(t, "D", string(test.FavouritecatTypeD))
			require.Contains(t, test.FavouritecatTypeD.Values(), test.FavouritecatTypeD)

			require.Equal(t, "E", string(test.FavouritecatTypeE))
			require.Contains(t, test.FavouritecatTypeE.Values(), test.FavouritecatTypeE)

			require.Equal(t, "F", string(test.FavouritecatTypeF))
			require.Contains(t, test.FavouritecatTypeF.Values(), test.FavouritecatTypeF)

		})
	})

	t.Run("structs", func(t *testing.T) {
		t.Run("Address", func(t *testing.T) {
			genStruct := &test.Address{
				County:      &strVal,
				District:    &strVal,
				FlatNumber:  &strVal,
				HouseName:   &strVal,
				HouseNumber: &strVal,
				Postcode:    &strVal,
				Street:      &strVal,
				Town:        &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &test.Address{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"county"`, strVal, "County")
				requireJmesMatch(t, jsearch, `"district"`, strVal, "District")
				requireJmesMatch(t, jsearch, `"flatNumber"`, strVal, "FlatNumber")
				requireJmesMatch(t, jsearch, `"houseName"`, strVal, "HouseName")
				requireJmesMatch(t, jsearch, `"houseNumber"`, strVal, "HouseNumber")
				requireJmesMatch(t, jsearch, `"postcode"`, strVal, "Postcode")
				requireJmesMatch(t, jsearch, `"street"`, strVal, "Street")
				requireJmesMatch(t, jsearch, `"town"`, strVal, "Town")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *test.Address{County: &strVal}.County)
				require.Equal(t, strVal, *test.Address{District: &strVal}.District)
				require.Equal(t, strVal, *test.Address{FlatNumber: &strVal}.FlatNumber)
				require.Equal(t, strVal, *test.Address{HouseName: &strVal}.HouseName)
				require.Equal(t, strVal, *test.Address{HouseNumber: &strVal}.HouseNumber)
				require.Equal(t, strVal, *test.Address{Postcode: &strVal}.Postcode)
				require.Equal(t, strVal, *test.Address{Street: &strVal}.Street)
				require.Equal(t, strVal, *test.Address{Town: &strVal}.Town)
			})
		})

		t.Run("Root", func(t *testing.T) {
			genStruct := &test.Root{
				Address: &test.Address{
					County:      &strVal,
					District:    &strVal,
					FlatNumber:  &strVal,
					HouseName:   &strVal,
					HouseNumber: &strVal,
					Postcode:    &strVal,
					Street:      &strVal,
					Town:        &strVal,
				},
				Name: &strVal,
				Status: &test.Status{
					Favouritecat: test.FavouritecatType("FAKE"),
				},
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &test.Root{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("address")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("status")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.Address) // Lazily Tested: test.Root.Address == *Address
				require.Equal(t, strVal, *test.Root{Name: &strVal}.Name)
				require.NotNil(t, genStruct.Status) // Lazily Tested: test.Root.Status == *Status
			})
		})

		t.Run("Status", func(t *testing.T) {
			genStruct := &test.Status{
				Favouritecat: test.FavouritecatType("FAKE"),
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &test.Status{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("favouritecat")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.Favouritecat) // Lazily Tested: test.Status.Favouritecat == FavouritecatType
			})
		})

	})

}
