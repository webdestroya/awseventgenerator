// Code generated by awseventgenerator/internal/generators/testcode. DO NOT EDIT.

package testsuitegenerated

import (
	"encoding/json"
	"github.com/stretchr/testify/require"
	"testing"
	"time"

	additionalproperties2 "github.com/webdestroya/awseventgenerator/internal/testcode/additionalproperties2_gen"
)

func TestGenerated_additionalproperties2(t *testing.T) {

	strVal := "someString"
	floatVal := float64(1232.1424)
	intVal := int64(1232)
	timeVal := time.Now().UTC()
	trueVal := true
	anyVal := struct {
		Thing string `json:"thinger"`
	}{Thing: "anywayanyday"}

	require.IsType(t, *new(string), strVal)
	require.IsType(t, *new(float64), floatVal)
	require.IsType(t, *new(int64), intVal)
	require.IsType(t, *new(time.Time), timeVal)
	require.IsType(t, *new(bool), trueVal)
	_ = anyVal

	t.Run("structs", func(t *testing.T) {
		t.Run("Address", func(t *testing.T) {
			genStruct := &additionalproperties2.Address{
				City: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Address{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"city"`, strVal, "City")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *additionalproperties2.Address{City: &strVal}.City)
			})
		})

		t.Run("Anonymous1", func(t *testing.T) {
			genStruct := &additionalproperties2.Anonymous1{
				Color: &strVal,
				Conditions: []additionalproperties2.ConditionsItems{{
					Name: &strVal,
				}},
				Density: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Anonymous1{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"color"`, strVal, "Color")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("conditions")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"density"`, floatVal, "Density")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *additionalproperties2.Anonymous1{Color: &strVal}.Color)
				require.NotNil(t, genStruct.Conditions) // Lazily Tested: additionalproperties2.Anonymous1.Conditions == []ConditionsItems
				require.Equal(t, floatVal, *additionalproperties2.Anonymous1{Density: &floatVal}.Density)
			})
		})

		t.Run("ConditionsItems", func(t *testing.T) {
			genStruct := &additionalproperties2.ConditionsItems{
				Name: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.ConditionsItems{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"name"`, strVal, "Name")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *additionalproperties2.ConditionsItems{Name: &strVal}.Name)
			})
		})

		t.Run("NotSoAnonymous", func(t *testing.T) {
			genStruct := &additionalproperties2.NotSoAnonymous{
				Subproperty1: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.NotSoAnonymous{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"subproperty1"`, floatVal, "Subproperty1")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, floatVal, *additionalproperties2.NotSoAnonymous{Subproperty1: &floatVal}.Subproperty1)
			})
		})

		t.Run("PoBox", func(t *testing.T) {
			genStruct := &additionalproperties2.PoBox{
				Suburb: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.PoBox{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"suburb"`, strVal, "Suburb")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *additionalproperties2.PoBox{Suburb: &strVal}.Suburb)
			})
		})

		t.Run("Property3", func(t *testing.T) {
			genStruct := &additionalproperties2.Property3{
				AdditionalProperties: map[string]float64{
					strVal: floatVal,
				},
				Age: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Property3{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"age"`, floatVal, "Age")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.AdditionalProperties) // Lazily Tested: additionalproperties2.Property3.AdditionalProperties == map[string]float64
				require.Equal(t, floatVal, *additionalproperties2.Property3{Age: &floatVal}.Age)
			})
		})

		t.Run("Property4", func(t *testing.T) {
			genStruct := &additionalproperties2.Property4{
				AdditionalProperties: map[string]string{
					strVal: strVal,
				},
				Age: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Property4{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"age"`, floatVal, "Age")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.AdditionalProperties) // Lazily Tested: additionalproperties2.Property4.AdditionalProperties == map[string]string
				require.Equal(t, floatVal, *additionalproperties2.Property4{Age: &floatVal}.Age)
			})
		})

		t.Run("Property5", func(t *testing.T) {
			genStruct := &additionalproperties2.Property5{
				AdditionalProperties: map[string]additionalproperties2.NotSoAnonymous{
					strVal: {
						Subproperty1: &floatVal,
					},
				},
				Age: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Property5{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"age"`, floatVal, "Age")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.AdditionalProperties) // Lazily Tested: additionalproperties2.Property5.AdditionalProperties == map[string]NotSoAnonymous
				require.Equal(t, floatVal, *additionalproperties2.Property5{Age: &floatVal}.Age)
			})
		})

		t.Run("Property6", func(t *testing.T) {
			genStruct := &additionalproperties2.Property6{
				AdditionalProperties: map[string]additionalproperties2.Property6Item{
					strVal: {
						Subproperty1: &floatVal,
					},
				},
				Age:     &floatVal,
				Pronoun: &strVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Property6{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"age"`, floatVal, "Age")
				requireJmesMatch(t, jsearch, `"pronoun"`, strVal, "Pronoun")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.AdditionalProperties) // Lazily Tested: additionalproperties2.Property6.AdditionalProperties == map[string]Property6Item
				require.Equal(t, floatVal, *additionalproperties2.Property6{Age: &floatVal}.Age)
				require.Equal(t, strVal, *additionalproperties2.Property6{Pronoun: &strVal}.Pronoun)
			})
		})

		t.Run("Property6Item", func(t *testing.T) {
			genStruct := &additionalproperties2.Property6Item{
				Subproperty1: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Property6Item{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"subproperty1"`, floatVal, "Subproperty1")

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, floatVal, *additionalproperties2.Property6Item{Subproperty1: &floatVal}.Subproperty1)
			})
		})

		t.Run("Property7", func(t *testing.T) {
			genStruct := &additionalproperties2.Property7{
				AdditionalProperties: map[string]map[string]additionalproperties2.Anonymous1{
					strVal: {
						strVal: {
							Color: &strVal,
							Conditions: []additionalproperties2.ConditionsItems{{
								Name: &strVal,
							}},
							Density: &floatVal,
						},
					},
				},
				PoBox: &additionalproperties2.PoBox{
					Suburb: &strVal,
				},
				StreetName:   &strVal,
				StreetNumber: &floatVal,
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Property7{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("po_box")`).(float64), 1.0)
				requireJmesMatch(t, jsearch, `"street_name"`, strVal, "StreetName")
				requireJmesMatch(t, jsearch, `"street_number"`, floatVal, "StreetNumber")

			})
			t.Run("fields", func(t *testing.T) {
				require.NotNil(t, genStruct.AdditionalProperties) // Lazily Tested: additionalproperties2.Property7.AdditionalProperties == map[string]map[string]Anonymous1
				require.NotNil(t, genStruct.PoBox)                // Lazily Tested: additionalproperties2.Property7.PoBox == *PoBox
				require.Equal(t, strVal, *additionalproperties2.Property7{StreetName: &strVal}.StreetName)
				require.Equal(t, floatVal, *additionalproperties2.Property7{StreetNumber: &floatVal}.StreetNumber)
			})
		})

		t.Run("Root", func(t *testing.T) {
			genStruct := &additionalproperties2.Root{
				Property1: &strVal,
				Property2: &additionalproperties2.Address{
					City: &strVal,
				},
				Property3: &additionalproperties2.Property3{
					AdditionalProperties: map[string]float64{
						strVal: floatVal,
					},
					Age: &floatVal,
				},
				Property4: &additionalproperties2.Property4{
					AdditionalProperties: map[string]string{
						strVal: strVal,
					},
					Age: &floatVal,
				},
				Property5: &additionalproperties2.Property5{
					AdditionalProperties: map[string]additionalproperties2.NotSoAnonymous{
						strVal: {
							Subproperty1: &floatVal,
						},
					},
					Age: &floatVal,
				},
				Property6: &additionalproperties2.Property6{
					AdditionalProperties: map[string]additionalproperties2.Property6Item{
						strVal: {
							Subproperty1: &floatVal,
						},
					},
					Age:     &floatVal,
					Pronoun: &strVal,
				},
				Property7: &additionalproperties2.Property7{
					AdditionalProperties: map[string]map[string]additionalproperties2.Anonymous1{
						strVal: {
							strVal: {
								Color: &strVal,
								Conditions: []additionalproperties2.ConditionsItems{{
									Name: &strVal,
								}},
								Density: &floatVal,
							},
						},
					},
					PoBox: &additionalproperties2.PoBox{
						Suburb: &strVal,
					},
					StreetName:   &strVal,
					StreetNumber: &floatVal,
				},
			}
			t.Run("json", func(t *testing.T) {
				jsonOut, err := json.Marshal(genStruct)
				require.NoError(t, err)

				unmarObj := &additionalproperties2.Root{}
				require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

				jsonOut2, err := json.Marshal(unmarObj)
				require.NoError(t, err)
				require.JSONEq(t, string(jsonOut), string(jsonOut2))

				var jsearch interface{}
				require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
				requireJmesMatch(t, jsearch, `"property1"`, strVal, "Property1")
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("property2")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("property3")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("property4")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("property5")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("property6")`).(float64), 1.0)
				require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("property7")`).(float64), 1.0)

			})
			t.Run("fields", func(t *testing.T) {
				require.Equal(t, strVal, *additionalproperties2.Root{Property1: &strVal}.Property1)
				require.NotNil(t, genStruct.Property2) // Lazily Tested: additionalproperties2.Root.Property2 == *Address
				require.NotNil(t, genStruct.Property3) // Lazily Tested: additionalproperties2.Root.Property3 == *Property3
				require.NotNil(t, genStruct.Property4) // Lazily Tested: additionalproperties2.Root.Property4 == *Property4
				require.NotNil(t, genStruct.Property5) // Lazily Tested: additionalproperties2.Root.Property5 == *Property5
				require.NotNil(t, genStruct.Property6) // Lazily Tested: additionalproperties2.Root.Property6 == *Property6
				require.NotNil(t, genStruct.Property7) // Lazily Tested: additionalproperties2.Root.Property7 == *Property7
			})
		})

	})

}
