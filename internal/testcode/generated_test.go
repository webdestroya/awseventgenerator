// Code generated by awseventgenerator/internal/generators/testcode. DO NOT EDIT.

package testcode

import (
	"encoding/json"
	"github.com/stretchr/testify/require"
	"testing"
	"time"

	everything "github.com/webdestroya/awseventgenerator/internal/testcode/everything_gen"
)

func TestGeneratedCode(t *testing.T) {

	strVal := "someString"
	floatVal := float64(1232.1424)
	timeVal := time.Now().UTC()
	trueVal := true

	require.IsType(t, *new(string), strVal)
	require.IsType(t, *new(float64), floatVal)
	require.IsType(t, *new(time.Time), timeVal)
	require.IsType(t, *new(bool), trueVal)

	t.Run("everything", func(t *testing.T) {

		t.Run("constants", func(t *testing.T) {
			require.Equal(t, `EverythingTest`, everything.AwsEventDetailType)
			require.Equal(t, `webdestroya.everything`, everything.AwsEventSource)
		})

		t.Run("enums", func(t *testing.T) {
			t.Run("ReadinessStatusType", func(t *testing.T) {
				require.Equal(t, "NOT_AUTHORIZED", string(everything.ReadinessStatusTypeNotAuthorized))
				require.Contains(t, everything.ReadinessStatusTypeNotAuthorized.Values(), everything.ReadinessStatusTypeNotAuthorized)

				require.Equal(t, "NOT_READY", string(everything.ReadinessStatusTypeNotReady))
				require.Contains(t, everything.ReadinessStatusTypeNotReady.Values(), everything.ReadinessStatusTypeNotReady)

				require.Equal(t, "READY", string(everything.ReadinessStatusTypeReady))
				require.Contains(t, everything.ReadinessStatusTypeReady.Values(), everything.ReadinessStatusTypeReady)

				require.Equal(t, "UNKNOWN", string(everything.ReadinessStatusTypeUnknown))
				require.Contains(t, everything.ReadinessStatusTypeUnknown.Values(), everything.ReadinessStatusTypeUnknown)

			})
		})

		t.Run("aliases", func(t *testing.T) {
			require.IsType(t, *new(map[string]string), *new(everything.Environment))
		})

		t.Run("structs", func(t *testing.T) {
			t.Run("AttachmentDetails", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.AttachmentDetails{
						Details: &everything.Details{
							Name:  &strVal,
							Value: &strVal,
						},
						Id:     &strVal,
						Status: &strVal,
						Type:   &strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.AttachmentDetails{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("details")`).(float64), 1.0)
					/* Details */
					requireJmesMatch(t, jsearch, `"id"`, strVal, "AttachmentDetails.Id(id)")
					requireJmesMatch(t, jsearch, `"status"`, strVal, "AttachmentDetails.Status(status)")
					requireJmesMatch(t, jsearch, `"type"`, strVal, "AttachmentDetails.Type(type)")

				})
				t.Run("fields", func(t *testing.T) {
					// UNKNOWN: everything.AttachmentDetails.Details == *Details
					require.Equal(t, strVal, *everything.AttachmentDetails{Id: &strVal}.Id)
					require.Equal(t, strVal, *everything.AttachmentDetails{Status: &strVal}.Status)
					require.Equal(t, strVal, *everything.AttachmentDetails{Type: &strVal}.Type)
				})
			})

			t.Run("AttributesDetails", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.AttributesDetails{
						Name:  &strVal,
						Value: &strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.AttributesDetails{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"name"`, strVal, "AttributesDetails.Name(name)")
					requireJmesMatch(t, jsearch, `"value"`, strVal, "AttributesDetails.Value(value)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Equal(t, strVal, *everything.AttributesDetails{Name: &strVal}.Name)
					require.Equal(t, strVal, *everything.AttributesDetails{Value: &strVal}.Value)
				})
			})

			t.Run("ContainerDetails", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.ContainerDetails{
						ContainerArn:      strVal,
						Cpu:               &strVal,
						ExitCode:          &floatVal,
						GpuIds:            []string{strVal},
						Image:             &strVal,
						ImageDigest:       &strVal,
						LastStatus:        strVal,
						Memory:            &strVal,
						MemoryReservation: &strVal,
						Name:              strVal,
						NetworkBindings: []everything.NetworkBindingDetails{{
							BindIP:        &strVal,
							ContainerPort: &floatVal,
							HostPort:      &floatVal,
							Protocol:      &strVal,
						}},
						NetworkInterfaces: []everything.NetworkInterfaceDetails{{
							AttachmentId:       &strVal,
							Ipv6Address:        &strVal,
							PrivateIpv4Address: &strVal,
						}},
						Reason:    &strVal,
						RuntimeId: &strVal,
						TaskArn:   strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.ContainerDetails{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"containerArn"`, strVal, "ContainerDetails.ContainerArn(containerArn)")
					requireJmesMatch(t, jsearch, `"cpu"`, strVal, "ContainerDetails.Cpu(cpu)")
					requireJmesMatch(t, jsearch, `"exitCode"`, floatVal, "ContainerDetails.ExitCode(exitCode)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("gpuIds")`).(float64), 1.0)
					/* GpuIds */
					requireJmesMatch(t, jsearch, `"image"`, strVal, "ContainerDetails.Image(image)")
					requireJmesMatch(t, jsearch, `"imageDigest"`, strVal, "ContainerDetails.ImageDigest(imageDigest)")
					requireJmesMatch(t, jsearch, `"lastStatus"`, strVal, "ContainerDetails.LastStatus(lastStatus)")
					requireJmesMatch(t, jsearch, `"memory"`, strVal, "ContainerDetails.Memory(memory)")
					requireJmesMatch(t, jsearch, `"memoryReservation"`, strVal, "ContainerDetails.MemoryReservation(memoryReservation)")
					requireJmesMatch(t, jsearch, `"name"`, strVal, "ContainerDetails.Name(name)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("networkBindings")`).(float64), 1.0)
					/* NetworkBindings */
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("networkInterfaces")`).(float64), 1.0)
					/* NetworkInterfaces */
					requireJmesMatch(t, jsearch, `"reason"`, strVal, "ContainerDetails.Reason(reason)")
					requireJmesMatch(t, jsearch, `"runtimeId"`, strVal, "ContainerDetails.RuntimeId(runtimeId)")
					requireJmesMatch(t, jsearch, `"taskArn"`, strVal, "ContainerDetails.TaskArn(taskArn)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Equal(t, strVal, everything.ContainerDetails{ContainerArn: strVal}.ContainerArn)
					require.Equal(t, strVal, *everything.ContainerDetails{Cpu: &strVal}.Cpu)
					require.Equal(t, floatVal, *everything.ContainerDetails{ExitCode: &floatVal}.ExitCode)
					require.Contains(t, everything.ContainerDetails{GpuIds: []string{strVal}}.GpuIds, strVal)
					require.Equal(t, strVal, *everything.ContainerDetails{Image: &strVal}.Image)
					require.Equal(t, strVal, *everything.ContainerDetails{ImageDigest: &strVal}.ImageDigest)
					require.Equal(t, strVal, everything.ContainerDetails{LastStatus: strVal}.LastStatus)
					require.Equal(t, strVal, *everything.ContainerDetails{Memory: &strVal}.Memory)
					require.Equal(t, strVal, *everything.ContainerDetails{MemoryReservation: &strVal}.MemoryReservation)
					require.Equal(t, strVal, everything.ContainerDetails{Name: strVal}.Name)
					// UNKNOWN: everything.ContainerDetails.NetworkBindings == []NetworkBindingDetails
					// UNKNOWN: everything.ContainerDetails.NetworkInterfaces == []NetworkInterfaceDetails
					require.Equal(t, strVal, *everything.ContainerDetails{Reason: &strVal}.Reason)
					require.Equal(t, strVal, *everything.ContainerDetails{RuntimeId: &strVal}.RuntimeId)
					require.Equal(t, strVal, everything.ContainerDetails{TaskArn: strVal}.TaskArn)
				})
			})

			t.Run("Details", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.Details{
						Name:  &strVal,
						Value: &strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.Details{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"name"`, strVal, "Details.Name(name)")
					requireJmesMatch(t, jsearch, `"value"`, strVal, "Details.Value(value)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Equal(t, strVal, *everything.Details{Name: &strVal}.Name)
					require.Equal(t, strVal, *everything.Details{Value: &strVal}.Value)
				})
			})

			t.Run("ECSTaskStateChange", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.ECSTaskStateChange{
						Attachments: []everything.AttachmentDetails{{
							Details: &everything.Details{
								Name:  &strVal,
								Value: &strVal,
							},
							Id:     &strVal,
							Status: &strVal,
							Type:   &strVal,
						}},
						Attributes: []everything.AttributesDetails{{
							Name:  &strVal,
							Value: &strVal,
						}},
						AvailabilityZone:     &strVal,
						ClusterArn:           strVal,
						Connectivity:         &strVal,
						ConnectivityAt:       &timeVal,
						ContainerInstanceArn: &strVal,
						Containers: []everything.ContainerDetails{{
							ContainerArn:      strVal,
							Cpu:               &strVal,
							ExitCode:          &floatVal,
							GpuIds:            []string{strVal},
							Image:             &strVal,
							ImageDigest:       &strVal,
							LastStatus:        strVal,
							Memory:            &strVal,
							MemoryReservation: &strVal,
							Name:              strVal,
							NetworkBindings: []everything.NetworkBindingDetails{{
								BindIP:        &strVal,
								ContainerPort: &floatVal,
								HostPort:      &floatVal,
								Protocol:      &strVal,
							}},
							NetworkInterfaces: []everything.NetworkInterfaceDetails{{
								AttachmentId:       &strVal,
								Ipv6Address:        &strVal,
								PrivateIpv4Address: &strVal,
							}},
							Reason:    &strVal,
							RuntimeId: &strVal,
							TaskArn:   strVal,
						}},
						Cpu:                &strVal,
						CreatedAt:          timeVal,
						DesiredStatus:      strVal,
						ExecutionStoppedAt: &timeVal,
						Extraobj: &everything.ExtraWithStrings{
							AdditionalProperties: map[string]string{
								strVal: strVal,
							},
							Somenum:  &floatVal,
							Someprop: &strVal,
						},
						Group:      &strVal,
						LastStatus: strVal,
						LaunchType: &strVal,
						Memory:     &strVal,
						Overrides: &everything.Overrides{
							ContainerOverrides: []everything.OverridesItem{{
								Command: []string{strVal},
								Cpu:     &floatVal,
								Environment: []everything.Environment{map[string]string{
									strVal: strVal,
								}},
								Memory: &floatVal,
								Name:   strVal,
							}},
						},
						PlatformVersion:   &strVal,
						PullStartedAt:     &timeVal,
						PullStoppedAt:     &timeVal,
						StartedAt:         &timeVal,
						StartedBy:         &strVal,
						StopCode:          &strVal,
						StoppedAt:         &timeVal,
						StoppedReason:     &strVal,
						StoppingAt:        &timeVal,
						TaskArn:           strVal,
						TaskDefinitionArn: strVal,
						UpdatedAt:         timeVal,
						Version:           floatVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.ECSTaskStateChange{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("attachments")`).(float64), 1.0)
					/* Attachments */
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("attributes")`).(float64), 1.0)
					/* Attributes */
					requireJmesMatch(t, jsearch, `"availabilityZone"`, strVal, "ECSTaskStateChange.AvailabilityZone(availabilityZone)")
					requireJmesMatch(t, jsearch, `"clusterArn"`, strVal, "ECSTaskStateChange.ClusterArn(clusterArn)")
					requireJmesMatch(t, jsearch, `"connectivity"`, strVal, "ECSTaskStateChange.Connectivity(connectivity)")
					requireJmesMatch(t, jsearch, `"connectivityAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.ConnectivityAt(connectivityAt)")
					requireJmesMatch(t, jsearch, `"containerInstanceArn"`, strVal, "ECSTaskStateChange.ContainerInstanceArn(containerInstanceArn)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("containers")`).(float64), 1.0)
					/* Containers */
					requireJmesMatch(t, jsearch, `"cpu"`, strVal, "ECSTaskStateChange.Cpu(cpu)")
					requireJmesMatch(t, jsearch, `"createdAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.CreatedAt(createdAt)")
					requireJmesMatch(t, jsearch, `"desiredStatus"`, strVal, "ECSTaskStateChange.DesiredStatus(desiredStatus)")
					requireJmesMatch(t, jsearch, `"executionStoppedAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.ExecutionStoppedAt(executionStoppedAt)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("extraobj")`).(float64), 1.0)
					/* Extraobj */
					requireJmesMatch(t, jsearch, `"group"`, strVal, "ECSTaskStateChange.Group(group)")
					requireJmesMatch(t, jsearch, `"lastStatus"`, strVal, "ECSTaskStateChange.LastStatus(lastStatus)")
					requireJmesMatch(t, jsearch, `"launchType"`, strVal, "ECSTaskStateChange.LaunchType(launchType)")
					requireJmesMatch(t, jsearch, `"memory"`, strVal, "ECSTaskStateChange.Memory(memory)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("overrides")`).(float64), 1.0)
					/* Overrides */
					requireJmesMatch(t, jsearch, `"platformVersion"`, strVal, "ECSTaskStateChange.PlatformVersion(platformVersion)")
					requireJmesMatch(t, jsearch, `"pullStartedAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.PullStartedAt(pullStartedAt)")
					requireJmesMatch(t, jsearch, `"pullStoppedAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.PullStoppedAt(pullStoppedAt)")
					requireJmesMatch(t, jsearch, `"startedAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.StartedAt(startedAt)")
					requireJmesMatch(t, jsearch, `"startedBy"`, strVal, "ECSTaskStateChange.StartedBy(startedBy)")
					requireJmesMatch(t, jsearch, `"stopCode"`, strVal, "ECSTaskStateChange.StopCode(stopCode)")
					requireJmesMatch(t, jsearch, `"stoppedAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.StoppedAt(stoppedAt)")
					requireJmesMatch(t, jsearch, `"stoppedReason"`, strVal, "ECSTaskStateChange.StoppedReason(stoppedReason)")
					requireJmesMatch(t, jsearch, `"stoppingAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.StoppingAt(stoppingAt)")
					requireJmesMatch(t, jsearch, `"taskArn"`, strVal, "ECSTaskStateChange.TaskArn(taskArn)")
					requireJmesMatch(t, jsearch, `"taskDefinitionArn"`, strVal, "ECSTaskStateChange.TaskDefinitionArn(taskDefinitionArn)")
					requireJmesMatch(t, jsearch, `"updatedAt"`, string(mustRet(timeVal.MarshalText())), "ECSTaskStateChange.UpdatedAt(updatedAt)")
					requireJmesMatch(t, jsearch, `"version"`, floatVal, "ECSTaskStateChange.Version(version)")

				})
				t.Run("fields", func(t *testing.T) {
					// UNKNOWN: everything.ECSTaskStateChange.Attachments == []AttachmentDetails
					// UNKNOWN: everything.ECSTaskStateChange.Attributes == []AttributesDetails
					require.Equal(t, strVal, *everything.ECSTaskStateChange{AvailabilityZone: &strVal}.AvailabilityZone)
					require.Equal(t, strVal, everything.ECSTaskStateChange{ClusterArn: strVal}.ClusterArn)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{Connectivity: &strVal}.Connectivity)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{ConnectivityAt: &timeVal}.ConnectivityAt)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{ContainerInstanceArn: &strVal}.ContainerInstanceArn)
					// UNKNOWN: everything.ECSTaskStateChange.Containers == []ContainerDetails
					require.Equal(t, strVal, *everything.ECSTaskStateChange{Cpu: &strVal}.Cpu)
					require.Equal(t, timeVal, everything.ECSTaskStateChange{CreatedAt: timeVal}.CreatedAt)
					require.Equal(t, strVal, everything.ECSTaskStateChange{DesiredStatus: strVal}.DesiredStatus)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{ExecutionStoppedAt: &timeVal}.ExecutionStoppedAt)
					// UNKNOWN: everything.ECSTaskStateChange.Extraobj == *ExtraWithStrings
					require.Equal(t, strVal, *everything.ECSTaskStateChange{Group: &strVal}.Group)
					require.Equal(t, strVal, everything.ECSTaskStateChange{LastStatus: strVal}.LastStatus)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{LaunchType: &strVal}.LaunchType)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{Memory: &strVal}.Memory)
					// UNKNOWN: everything.ECSTaskStateChange.Overrides == *Overrides
					require.Equal(t, strVal, *everything.ECSTaskStateChange{PlatformVersion: &strVal}.PlatformVersion)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{PullStartedAt: &timeVal}.PullStartedAt)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{PullStoppedAt: &timeVal}.PullStoppedAt)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{StartedAt: &timeVal}.StartedAt)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{StartedBy: &strVal}.StartedBy)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{StopCode: &strVal}.StopCode)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{StoppedAt: &timeVal}.StoppedAt)
					require.Equal(t, strVal, *everything.ECSTaskStateChange{StoppedReason: &strVal}.StoppedReason)
					require.Equal(t, timeVal, *everything.ECSTaskStateChange{StoppingAt: &timeVal}.StoppingAt)
					require.Equal(t, strVal, everything.ECSTaskStateChange{TaskArn: strVal}.TaskArn)
					require.Equal(t, strVal, everything.ECSTaskStateChange{TaskDefinitionArn: strVal}.TaskDefinitionArn)
					require.Equal(t, timeVal, everything.ECSTaskStateChange{UpdatedAt: timeVal}.UpdatedAt)
					require.Equal(t, floatVal, everything.ECSTaskStateChange{Version: floatVal}.Version)
				})
			})

			t.Run("ExtraWithStrings", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.ExtraWithStrings{
						AdditionalProperties: map[string]string{
							strVal: strVal,
						},
						Somenum:  &floatVal,
						Someprop: &strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.ExtraWithStrings{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"somenum"`, floatVal, "ExtraWithStrings.Somenum(somenum)")
					requireJmesMatch(t, jsearch, `"someprop"`, strVal, "ExtraWithStrings.Someprop(someprop)")

				})
				t.Run("fields", func(t *testing.T) {
					// UNKNOWN: everything.ExtraWithStrings.AdditionalProperties == map[string]string
					require.Equal(t, floatVal, *everything.ExtraWithStrings{Somenum: &floatVal}.Somenum)
					require.Equal(t, strVal, *everything.ExtraWithStrings{Someprop: &strVal}.Someprop)
				})
			})

			t.Run("NetworkBindingDetails", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.NetworkBindingDetails{
						BindIP:        &strVal,
						ContainerPort: &floatVal,
						HostPort:      &floatVal,
						Protocol:      &strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.NetworkBindingDetails{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"bindIP"`, strVal, "NetworkBindingDetails.BindIP(bindIP)")
					requireJmesMatch(t, jsearch, `"containerPort"`, floatVal, "NetworkBindingDetails.ContainerPort(containerPort)")
					requireJmesMatch(t, jsearch, `"hostPort"`, floatVal, "NetworkBindingDetails.HostPort(hostPort)")
					requireJmesMatch(t, jsearch, `"protocol"`, strVal, "NetworkBindingDetails.Protocol(protocol)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Equal(t, strVal, *everything.NetworkBindingDetails{BindIP: &strVal}.BindIP)
					require.Equal(t, floatVal, *everything.NetworkBindingDetails{ContainerPort: &floatVal}.ContainerPort)
					require.Equal(t, floatVal, *everything.NetworkBindingDetails{HostPort: &floatVal}.HostPort)
					require.Equal(t, strVal, *everything.NetworkBindingDetails{Protocol: &strVal}.Protocol)
				})
			})

			t.Run("NetworkInterfaceDetails", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.NetworkInterfaceDetails{
						AttachmentId:       &strVal,
						Ipv6Address:        &strVal,
						PrivateIpv4Address: &strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.NetworkInterfaceDetails{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"attachmentId"`, strVal, "NetworkInterfaceDetails.AttachmentId(attachmentId)")
					requireJmesMatch(t, jsearch, `"ipv6Address"`, strVal, "NetworkInterfaceDetails.Ipv6Address(ipv6Address)")
					requireJmesMatch(t, jsearch, `"privateIpv4Address"`, strVal, "NetworkInterfaceDetails.PrivateIpv4Address(privateIpv4Address)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Equal(t, strVal, *everything.NetworkInterfaceDetails{AttachmentId: &strVal}.AttachmentId)
					require.Equal(t, strVal, *everything.NetworkInterfaceDetails{Ipv6Address: &strVal}.Ipv6Address)
					require.Equal(t, strVal, *everything.NetworkInterfaceDetails{PrivateIpv4Address: &strVal}.PrivateIpv4Address)
				})
			})

			t.Run("Overrides", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.Overrides{
						ContainerOverrides: []everything.OverridesItem{{
							Command: []string{strVal},
							Cpu:     &floatVal,
							Environment: []everything.Environment{map[string]string{
								strVal: strVal,
							}},
							Memory: &floatVal,
							Name:   strVal,
						}},
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.Overrides{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("containerOverrides")`).(float64), 1.0)
					/* ContainerOverrides */

				})
				t.Run("fields", func(t *testing.T) {
					// UNKNOWN: everything.Overrides.ContainerOverrides == []OverridesItem
				})
			})

			t.Run("OverridesItem", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.OverridesItem{
						Command: []string{strVal},
						Cpu:     &floatVal,
						Environment: []everything.Environment{map[string]string{
							strVal: strVal,
						}},
						Memory: &floatVal,
						Name:   strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.OverridesItem{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("command")`).(float64), 1.0)
					/* Command */
					requireJmesMatch(t, jsearch, `"cpu"`, floatVal, "OverridesItem.Cpu(cpu)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("environment")`).(float64), 1.0)
					/* Environment */
					requireJmesMatch(t, jsearch, `"memory"`, floatVal, "OverridesItem.Memory(memory)")
					requireJmesMatch(t, jsearch, `"name"`, strVal, "OverridesItem.Name(name)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Contains(t, everything.OverridesItem{Command: []string{strVal}}.Command, strVal)
					require.Equal(t, floatVal, *everything.OverridesItem{Cpu: &floatVal}.Cpu)
					// UNKNOWN: everything.OverridesItem.Environment == []Environment
					require.Equal(t, floatVal, *everything.OverridesItem{Memory: &floatVal}.Memory)
					require.Equal(t, strVal, everything.OverridesItem{Name: strVal}.Name)
				})
			})

			t.Run("RecoveryGroupStatusChange", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.RecoveryGroupStatusChange{
						NewState: &everything.State{
							ReadinessStatus: everything.ReadinessStatusType("FAKE"),
						},
						PreviousState: &everything.State{
							ReadinessStatus: everything.ReadinessStatusType("FAKE"),
						},
						RecoveryGroupName: strVal,
						Taskchange: &everything.ECSTaskStateChange{
							Attachments: []everything.AttachmentDetails{{
								Details: &everything.Details{
									Name:  &strVal,
									Value: &strVal,
								},
								Id:     &strVal,
								Status: &strVal,
								Type:   &strVal,
							}},
							Attributes: []everything.AttributesDetails{{
								Name:  &strVal,
								Value: &strVal,
							}},
							AvailabilityZone:     &strVal,
							ClusterArn:           strVal,
							Connectivity:         &strVal,
							ConnectivityAt:       &timeVal,
							ContainerInstanceArn: &strVal,
							Containers: []everything.ContainerDetails{{
								ContainerArn:      strVal,
								Cpu:               &strVal,
								ExitCode:          &floatVal,
								GpuIds:            []string{strVal},
								Image:             &strVal,
								ImageDigest:       &strVal,
								LastStatus:        strVal,
								Memory:            &strVal,
								MemoryReservation: &strVal,
								Name:              strVal,
								NetworkBindings: []everything.NetworkBindingDetails{{
									BindIP:        &strVal,
									ContainerPort: &floatVal,
									HostPort:      &floatVal,
									Protocol:      &strVal,
								}},
								NetworkInterfaces: []everything.NetworkInterfaceDetails{{
									AttachmentId:       &strVal,
									Ipv6Address:        &strVal,
									PrivateIpv4Address: &strVal,
								}},
								Reason:    &strVal,
								RuntimeId: &strVal,
								TaskArn:   strVal,
							}},
							Cpu:                &strVal,
							CreatedAt:          timeVal,
							DesiredStatus:      strVal,
							ExecutionStoppedAt: &timeVal,
							Extraobj: &everything.ExtraWithStrings{
								AdditionalProperties: map[string]string{
									strVal: strVal,
								},
								Somenum:  &floatVal,
								Someprop: &strVal,
							},
							Group:      &strVal,
							LastStatus: strVal,
							LaunchType: &strVal,
							Memory:     &strVal,
							Overrides: &everything.Overrides{
								ContainerOverrides: []everything.OverridesItem{{
									Command: []string{strVal},
									Cpu:     &floatVal,
									Environment: []everything.Environment{map[string]string{
										strVal: strVal,
									}},
									Memory: &floatVal,
									Name:   strVal,
								}},
							},
							PlatformVersion:   &strVal,
							PullStartedAt:     &timeVal,
							PullStoppedAt:     &timeVal,
							StartedAt:         &timeVal,
							StartedBy:         &strVal,
							StopCode:          &strVal,
							StoppedAt:         &timeVal,
							StoppedReason:     &strVal,
							StoppingAt:        &timeVal,
							TaskArn:           strVal,
							TaskDefinitionArn: strVal,
							UpdatedAt:         timeVal,
							Version:           floatVal,
						},
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.RecoveryGroupStatusChange{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("new-state")`).(float64), 1.0)
					/* NewState */
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("previous-state")`).(float64), 1.0)
					/* PreviousState */
					requireJmesMatch(t, jsearch, `"recovery-group-name"`, strVal, "RecoveryGroupStatusChange.RecoveryGroupName(recovery-group-name)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("taskchange")`).(float64), 1.0)
					/* Taskchange */

				})
				t.Run("fields", func(t *testing.T) {
					// UNKNOWN: everything.RecoveryGroupStatusChange.NewState == *State
					// UNKNOWN: everything.RecoveryGroupStatusChange.PreviousState == *State
					require.Equal(t, strVal, everything.RecoveryGroupStatusChange{RecoveryGroupName: strVal}.RecoveryGroupName)
					// UNKNOWN: everything.RecoveryGroupStatusChange.Taskchange == *ECSTaskStateChange
				})
			})

			t.Run("Root", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.Root{
						Account: strVal,
						Detail: &everything.RecoveryGroupStatusChange{
							NewState: &everything.State{
								ReadinessStatus: everything.ReadinessStatusType("FAKE"),
							},
							PreviousState: &everything.State{
								ReadinessStatus: everything.ReadinessStatusType("FAKE"),
							},
							RecoveryGroupName: strVal,
							Taskchange: &everything.ECSTaskStateChange{
								Attachments: []everything.AttachmentDetails{{
									Details: &everything.Details{
										Name:  &strVal,
										Value: &strVal,
									},
									Id:     &strVal,
									Status: &strVal,
									Type:   &strVal,
								}},
								Attributes: []everything.AttributesDetails{{
									Name:  &strVal,
									Value: &strVal,
								}},
								AvailabilityZone:     &strVal,
								ClusterArn:           strVal,
								Connectivity:         &strVal,
								ConnectivityAt:       &timeVal,
								ContainerInstanceArn: &strVal,
								Containers: []everything.ContainerDetails{{
									ContainerArn:      strVal,
									Cpu:               &strVal,
									ExitCode:          &floatVal,
									GpuIds:            []string{strVal},
									Image:             &strVal,
									ImageDigest:       &strVal,
									LastStatus:        strVal,
									Memory:            &strVal,
									MemoryReservation: &strVal,
									Name:              strVal,
									NetworkBindings: []everything.NetworkBindingDetails{{
										BindIP:        &strVal,
										ContainerPort: &floatVal,
										HostPort:      &floatVal,
										Protocol:      &strVal,
									}},
									NetworkInterfaces: []everything.NetworkInterfaceDetails{{
										AttachmentId:       &strVal,
										Ipv6Address:        &strVal,
										PrivateIpv4Address: &strVal,
									}},
									Reason:    &strVal,
									RuntimeId: &strVal,
									TaskArn:   strVal,
								}},
								Cpu:                &strVal,
								CreatedAt:          timeVal,
								DesiredStatus:      strVal,
								ExecutionStoppedAt: &timeVal,
								Extraobj: &everything.ExtraWithStrings{
									AdditionalProperties: map[string]string{
										strVal: strVal,
									},
									Somenum:  &floatVal,
									Someprop: &strVal,
								},
								Group:      &strVal,
								LastStatus: strVal,
								LaunchType: &strVal,
								Memory:     &strVal,
								Overrides: &everything.Overrides{
									ContainerOverrides: []everything.OverridesItem{{
										Command: []string{strVal},
										Cpu:     &floatVal,
										Environment: []everything.Environment{map[string]string{
											strVal: strVal,
										}},
										Memory: &floatVal,
										Name:   strVal,
									}},
								},
								PlatformVersion:   &strVal,
								PullStartedAt:     &timeVal,
								PullStoppedAt:     &timeVal,
								StartedAt:         &timeVal,
								StartedBy:         &strVal,
								StopCode:          &strVal,
								StoppedAt:         &timeVal,
								StoppedReason:     &strVal,
								StoppingAt:        &timeVal,
								TaskArn:           strVal,
								TaskDefinitionArn: strVal,
								UpdatedAt:         timeVal,
								Version:           floatVal,
							},
						},
						DetailType: strVal,
						Id:         strVal,
						Region:     strVal,
						Resources:  []string{strVal},
						Source:     strVal,
						Time:       timeVal,
						Version:    strVal,
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.Root{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					requireJmesMatch(t, jsearch, `"account"`, strVal, "Root.Account(account)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("detail")`).(float64), 1.0)
					/* Detail */
					requireJmesMatch(t, jsearch, `"detail-type"`, strVal, "Root.DetailType(detail-type)")
					requireJmesMatch(t, jsearch, `"id"`, strVal, "Root.Id(id)")
					requireJmesMatch(t, jsearch, `"region"`, strVal, "Root.Region(region)")
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("resources")`).(float64), 1.0)
					/* Resources */
					requireJmesMatch(t, jsearch, `"source"`, strVal, "Root.Source(source)")
					requireJmesMatch(t, jsearch, `"time"`, string(mustRet(timeVal.MarshalText())), "Root.Time(time)")
					requireJmesMatch(t, jsearch, `"version"`, strVal, "Root.Version(version)")

				})
				t.Run("fields", func(t *testing.T) {
					require.Equal(t, strVal, everything.Root{Account: strVal}.Account)
					// UNKNOWN: everything.Root.Detail == *RecoveryGroupStatusChange
					require.Equal(t, strVal, everything.Root{DetailType: strVal}.DetailType)
					require.Equal(t, strVal, everything.Root{Id: strVal}.Id)
					require.Equal(t, strVal, everything.Root{Region: strVal}.Region)
					require.Contains(t, everything.Root{Resources: []string{strVal}}.Resources, strVal)
					require.Equal(t, strVal, everything.Root{Source: strVal}.Source)
					require.Equal(t, timeVal, everything.Root{Time: timeVal}.Time)
					require.Equal(t, strVal, everything.Root{Version: strVal}.Version)
				})
			})

			t.Run("State", func(t *testing.T) {
				t.Run("json", func(t *testing.T) {
					genStruct := &everything.State{
						ReadinessStatus: everything.ReadinessStatusType("FAKE"),
					}
					jsonOut, err := json.Marshal(genStruct)
					require.NoError(t, err)

					unmarObj := &everything.State{}
					require.NoError(t, json.Unmarshal(jsonOut, unmarObj))

					jsonOut2, err := json.Marshal(unmarObj)
					require.NoError(t, err)
					require.JSONEq(t, string(jsonOut), string(jsonOut2))

					var jsearch interface{}
					require.NoError(t, json.Unmarshal(jsonOut, &jsearch))
					require.GreaterOrEqual(t, jmesMatch(t, jsearch, `length("readiness-status")`).(float64), 1.0)
					/* ReadinessStatus */

				})
				t.Run("fields", func(t *testing.T) {
					// UNKNOWN: everything.State.ReadinessStatus == ReadinessStatusType
				})
			})

		})
	})

}
